---
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

typedef struct lock_support {
    volatile int locked;
    pthread_mutex_t mutex;
    pthread_cond_t locked_cond;
} lock_support_t;

typedef struct mutex_node {
    lock_support_t* mutex;
    struct mutex_node* next;
} mutex_node_t;

lock_support_t* lock_support_init() {
    lock_support_t * ls = (lock_support_t *) malloc(sizeof(lock_support_t));
    ls->locked = 0;
    pthread_mutex_init(&ls->mutex, NULL);
    pthread_cond_init(&ls->locked_cond, NULL);
    return ls;
}

mutex_node_t* mutex_node_init(mutex_node_t* mutexNode) {
    mutexNode->mutex = lock_support_init();
    mutexNode->next = NULL;
    return mutexNode;
}

void lock(lock_support_t* ls) {
    pthread_mutex_lock(&ls->mutex);
    while (ls->locked == 1) { // wait till locked is available
        pthread_cond_wait(&ls->locked_cond, &ls->mutex);
    }
    ls->locked = 1;
    pthread_mutex_unlock(&ls->mutex);
}

void unlock(lock_support_t* ls) {
    pthread_mutex_lock(&ls->mutex);
    ls->locked = 0;
    pthread_cond_broadcast(&ls->locked_cond);
    pthread_mutex_unlock(&ls->mutex);
}

// --------- Fat lock support

// Wrapper on top of mutex so its consistent type across all POSIX-supported platforms

typedef struct fat_lock {
    pthread_mutex_t mutex;
} fat_lock_t;

typedef struct fat_lock_condition {
    pthread_cond_t condition;
} fat_lock_condition_t;

fat_lock_t* fat_lock_init() {
    fat_lock_t* fl = (fat_lock_t*) malloc(sizeof(fat_lock_t));
    pthread_mutex_init(&fl->mutex, NULL);
    return fl;
}

void lock_fat(fat_lock_t* fl) {
    pthread_mutex_lock(&fl->mutex);
}

void unlock_fat(fat_lock_t* fl) {
    pthread_mutex_unlock(&fl->mutex);
}

void fat_lock_destroy(fat_lock_t* fl) {
    pthread_mutex_destroy(&fl->mutex);
    free(fl);
}

// Conditions

fat_lock_condition_t* fat_lock_condition_init() {
    fat_lock_condition_t* flc = (fat_lock_condition_t*) malloc(sizeof(fat_lock_condition_t));
    pthread_cond_init(&flc->condition, NULL);
    return flc;
}

void cond_wait(fat_lock_t* fl, fat_lock_condition_t* flc) {
    pthread_cond_wait(&flc->condition, &fl->mutex);
}

void cond_notify_all(fat_lock_condition_t* flc) {
    pthread_cond_broadcast(&flc->condition);
}

void cond_notify_one(fat_lock_condition_t* flc) {
    pthread_cond_signal(&flc->condition);
}

void fat_lock_condition_destroy(fat_lock_condition_t* flc) {
    pthread_mutex_destroy(&flc->condition);
    free(flc);
}
