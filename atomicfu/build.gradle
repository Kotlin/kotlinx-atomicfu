/*
 * Copyright 2016-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license.
 */

import org.jetbrains.kotlin.gradle.plugin.mpp.KotlinNativeTarget
import org.jetbrains.kotlin.gradle.tasks.KotlinJvmCompile

plugins {
    id("kotlin-multiplatform-conventions")
    id("kotlin-multiplatform-publish-conventions")
}

ext {
    nativeMainSets = []
    nativeTestSets = []

    addNative = { preset ->
        nativeMainSets.add(preset.compilations['main'].kotlinSourceSets.first())
        nativeTestSets.add(preset.compilations['test'].kotlinSourceSets.first())
    }
}


kotlin {
    targets {
        delegate.metaClass.addTarget = { preset ->
            addNative(delegate.fromPreset(preset, preset.name))
        }
    }

    // JS -- always
    js(IR) {
        moduleName = "kotlinx-atomicfu"
        // TODO: commented out because browser tests do not work on TeamCity
        // browser()
        nodejs()
    }

    // JVM -- always
    jvm()

    // Wasm -- always
    wasmJs {
        nodejs()
    }

    wasmWasi {
        nodejs()
    }

    sourceSets {
        commonMain {
            dependencies {
                implementation('org.jetbrains.kotlin:kotlin-stdlib') {
                    version {
                        prefer libs.versions.kotlin.get()
                    }
                }
            }
        }
        commonTest {
            dependencies {
                implementation 'org.jetbrains.kotlin:kotlin-test-common'
                implementation 'org.jetbrains.kotlin:kotlin-test-annotations-common'
            }
        }

        jsAndWasmSharedMain {
            dependsOn(sourceSets.commonMain)
        }

        jsMain {
            dependsOn(sourceSets.jsAndWasmSharedMain)
            dependencies {
                compileOnly 'org.jetbrains.kotlin:kotlin-stdlib-js'
                compileOnly 'org.jetbrains.kotlin:kotlin-dom-api-compat'
            }
        }
        jsTest {
            dependencies {
                implementation 'org.jetbrains.kotlin:kotlin-test-js'
            }
        }

        wasmJsMain {
            dependsOn(sourceSets.jsAndWasmSharedMain)
            dependencies {
                compileOnly 'org.jetbrains.kotlin:kotlin-stdlib-wasm-js'
            }
        }

        wasmJsTest {
            dependencies {
                implementation 'org.jetbrains.kotlin:kotlin-test-wasm-js'
            }
        }

        wasmWasiMain {
            dependsOn(sourceSets.jsAndWasmSharedMain)
            dependencies {
                compileOnly 'org.jetbrains.kotlin:kotlin-stdlib-wasm-wasi'
            }
        }
        wasmWasiTest {
            dependencies {
                implementation 'org.jetbrains.kotlin:kotlin-test-wasm-wasi'
            }
        }

        jvmMain {
            dependencies {
                compileOnly 'org.jetbrains.kotlin:kotlin-stdlib'
            }
        }
        jvmTest {
            dependencies {
                implementation 'org.jetbrains.kotlin:kotlin-reflect'
                implementation 'org.jetbrains.kotlin:kotlin-test'
                implementation 'org.jetbrains.kotlin:kotlin-test-junit'
                implementation libs.junit.junit
            }
        }
    }
}

// Support of all non-deprecated targets from official tier list: https://kotlinlang.org/docs/native-target-support.html
kotlin {
    // Apple targets
    // Tier 1
    macosX64()
    macosArm64()
    iosSimulatorArm64()
    iosX64()

    // Tier 2
    watchosSimulatorArm64()
    watchosX64()
    watchosArm32()
    watchosArm64()
    tvosSimulatorArm64()
    tvosX64()
    tvosArm64()
    iosArm64()

    // Tier 3
    watchosDeviceArm64()

    // Tier 2
    linuxX64()
    linuxArm64()

    // Tier 3
    androidNativeArm32()
    androidNativeArm64()
    androidNativeX86()
    androidNativeX64()
    mingwX64()

    applyDefaultHierarchyTemplate { target ->
        target.group("nativeNonApple") { nativeTargets ->
            nativeTargets.group("nativeUnixLike") {
                it.withLinux()
            }
            nativeTargets.group("androidNative32Bit") {
                it.withAndroidNativeX86()
                // This is a WA: in KotlinHierarchyBuilderImpl.withAndroidNativeArm32 the KonanTarget equals ANDROID_X86 instead of ANDROID_ARM32
                it.withCompilations { compilation ->
                    compilation.target instanceof KotlinNativeTarget && (compilation.target as KotlinNativeTarget).konanTarget.name == "android_arm32"
                }
            }
            nativeTargets.group("androidNative64Bit") {
                it.withAndroidNativeArm64()
                it.withAndroidNativeX64()
            }
        }
        target.group("apple") {
            it.withApple()
        }
    }

    sourceSets {
        nativeMain {
            dependsOn commonMain
        }

        nativeTest {}

        nativeNonAppleMain {
            kotlin.srcDir("src/nativeNonAppleMain/kotlin")
            dependsOn commonMain
        }

        appleMain {
            kotlin.srcDir("src/appleMain/kotlin")
            dependsOn commonMain
        }

        nativeUnixLikeMain {
            kotlin.srcDir("src/nativeUnixLikeMain/kotlin")
            dependsOn nativeNonAppleMain
        }

        androidNative32BitMain {
            kotlin.srcDir("src/androidNative32BitMain/kotlin")
            dependsOn nativeNonAppleMain
        }

        androidNative64BitMain {
            kotlin.srcDir("src/androidNative64BitMain/kotlin")
            dependsOn nativeNonAppleMain
        }

        mingwX64Main { dependsOn nativeNonAppleMain }

        configure(nativeMainSets) {
            dependsOn nativeMain
        }

        configure(nativeTestSets) {
            dependsOn nativeTest
        }
    }

    // atomicfu-cinterop-interop.klib with an empty interop.def file will still be published for compatibility reasons (see KT-68411)
    // This block can be removed when this issue in K/N compiler is resolved: KT-60874
    targets.withType(KotlinNativeTarget).configureEach { nativeTarget ->
        nativeTarget.compilations.configureEach { nativeCompilation ->
            nativeCompilation.cinterops {
                interop {
                    defFile file('src/nativeInterop/cinterop/interop.def')
                }
            }
        }
    }
}

configurations {
    transformer
}

dependencies {
    transformer project(":atomicfu-transformer")
}

// ==== CONFIGURE JVM =====

def classesPreAtomicFuDir = file("$buildDir/classes/kotlin/jvm/test")
def classesPostTransformFU = file("$buildDir/classes/kotlin/jvm/postTransformedFU")
def classesPostTransformVH = file("$buildDir/classes/kotlin/jvm/postTransformedVH")
def classesPostTransformBOTH = file("$buildDir/classes/kotlin/jvm/postTransformedBOTH")

tasks.withType(compileTestKotlinJvm.getClass()) {
    kotlinOptions {
        jvmTarget = "1.8"
    }
}

task transformFU(type: JavaExec, dependsOn: compileTestKotlinJvm) {
    main = "kotlinx.atomicfu.transformer.AtomicFUTransformerKt"
    args = [classesPreAtomicFuDir, classesPostTransformFU, "FU"]
    classpath = configurations.transformer
    inputs.dir(classesPreAtomicFuDir)
    outputs.dir(classesPostTransformFU)
}

task transformBOTH(type: JavaExec, dependsOn: compileTestKotlinJvm) {
    main = "kotlinx.atomicfu.transformer.AtomicFUTransformerKt"
    args = [classesPreAtomicFuDir, classesPostTransformBOTH, "BOTH"]
    classpath = configurations.transformer
    inputs.dir(classesPreAtomicFuDir)
    outputs.dir(classesPostTransformBOTH)
}

task transformVH(type: JavaExec, dependsOn: compileTestKotlinJvm) {
    main = "kotlinx.atomicfu.transformer.AtomicFUTransformerKt"
    args = [classesPreAtomicFuDir, classesPostTransformVH, "VH"]
    classpath = configurations.transformer
    inputs.dir(classesPreAtomicFuDir)
    outputs.dir(classesPostTransformVH)
}

task transformedTestFU_current(type: Test, dependsOn: transformFU) {
    classpath = files(configurations.jvmTestRuntimeClasspath, classesPostTransformFU)
    testClassesDirs = project.files(classesPostTransformFU)
    exclude '**/*LFTest.*', '**/TraceToStringTest.*', '**/AtomicfuReferenceJsTest.*'
    filter { setFailOnNoMatchingTests(false) }
}

task transformedTestBOTH_current(type: Test, dependsOn: transformBOTH) {
    classpath = files(configurations.jvmTestRuntimeClasspath, classesPostTransformBOTH)
    testClassesDirs = project.files(classesPostTransformBOTH)
    exclude '**/*LFTest.*', '**/TraceToStringTest.*', '**/TopLevelGeneratedDeclarationsReflectionTest.*', '**/SyntheticFUFieldsTest.*', '**/AtomicfuReferenceJsTest.*'
    filter { setFailOnNoMatchingTests(false) }
}

task transformedTestVH(type: Test, dependsOn: transformVH) {
    classpath = files(configurations.jvmTestRuntimeClasspath, classesPostTransformVH)
    testClassesDirs = project.files(classesPostTransformVH)
    exclude '**/*LFTest.*', '**/TraceToStringTest.*', '**/TopLevelGeneratedDeclarationsReflectionTest.*', '**/SyntheticFUFieldsTest.*', '**/AtomicfuReferenceJsTest.*'
    filter { setFailOnNoMatchingTests(false) }
}

transformedTestVH.onlyIf {
    logger.println(JavaVersion.current())
    JavaVersion.current().ordinal() >= JavaVersion.VERSION_1_9.ordinal()
}

task jvmTestAll(dependsOn: [
        transformedTestFU_current,
        transformedTestBOTH_current,
        transformedTestVH
])

tasks.withType(Test) {
    testLogging {
        showStandardStreams = true
        events "passed", "failed"
    }
}

task compileJavaModuleInfo(type: JavaCompile) {
    def moduleName = "kotlinx.atomicfu" // this module's name
    def compilation = kotlin.targets["jvm"].compilations["main"]
    def compileKotlinTask = compilation.compileTaskProvider.get() as KotlinJvmCompile
    def targetDir = compileKotlinTask.destinationDirectory.dir("../java9")
    def sourceDir = file("src/jvmMain/java9/")

    // Use a Java 11 compiler for the module info.
    javaCompiler.set(project.javaToolchains.compilerFor { languageVersion.set(JavaLanguageVersion.of(11)) })

    // Always compile kotlin classes before the module descriptor.
    dependsOn(compileKotlinTask)

    // Add the module-info source file.
    source(sourceDir)

    // Also add the module-info.java source file to the Kotlin compile task.
    // The Kotlin compiler will parse and check module dependencies,
    // but it currently won't compile to a module-info.class file.
    // Note that module checking only works on JDK 9+,
    // because the JDK built-in base modules are not available in earlier versions.
    def javaVersion = compileKotlinTask.kotlinJavaToolchain.javaVersion.getOrNull()
    if (javaVersion?.isJava9Compatible() == true) {
        logger.info("Module-info checking is enabled; $compileKotlinJvm is compiled using Java $javaVersion")
        compileKotlinJvm.source(sourceDir)
    } else {
        logger.info("Module-info checking is disabled")
    }

    // Set the task outputs and destination dir
    outputs.dir(targetDir)
    destinationDirectory.set(targetDir)

    // Configure JVM compatibility
    sourceCompatibility = JavaVersion.VERSION_1_9.toString()
    targetCompatibility = JavaVersion.VERSION_1_9.toString()

    // Set the Java release version.
    options.release.set(9)

    // Ignore warnings about using 'requires transitive' on automatic modules.
    // not needed when compiling with recent JDKs, e.g. 17
    options.compilerArgs.add("-Xlint:-requires-transitive-automatic")

    // Patch the compileKotlinJvm output classes into the compilation so exporting packages works correctly.
    options.compilerArgs.addAll(["--patch-module", "$moduleName=${compileKotlinTask.destinationDirectory.get().getAsFile()}"])

    // Use the classpath of the compileKotlinJvm task.
    // Also ensure that the module path is used instead of classpath.
    classpath = compileKotlinTask.libraries
    modularity.inferModulePath.set(true)

    doFirst {
        logger.warn("Task destination directory: ${destinationDirectory.get().getAsFile()}")
    }
}

// Configure the JAR task so that it will include the compiled module-info class file.
tasks.named("jvmJar") {
    manifest {
        attributes(["Multi-Release": true])
    }
    from(compileJavaModuleInfo.destinationDirectory) {
        into("META-INF/versions/9/")
    }
}

jvmTest {
    exclude "**/AtomicfuBytecodeTest*", "**/AtomicfuReferenceJsTest*", '**/TopLevelGeneratedDeclarationsReflectionTest.*', '**/SyntheticFUFieldsTest.*'
    // run them only for transformed code
}

jvmTest.dependsOn jvmTestAll

tasks.matching { it.name == "generatePomFileForKotlinMultiplatformPublication" }.configureEach {
    dependsOn(tasks["generatePomFileForJvmPublication"])
}

// Workaround for https://youtrack.jetbrains.com/issue/KT-58303:
// the `clean` task can't delete the expanded.lock file on Windows as it's still held by Gradle, failing the build
tasks.clean {
    setDelete(layout.buildDirectory.asFileTree.matching {
        exclude("tmp/.cache/expanded/expanded.lock")
    })
}
